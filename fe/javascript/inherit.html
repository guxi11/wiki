<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript常用的八种继承方案 | Guxi11 的知识库</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="">
    <link rel="preload" href="/wiki/assets/css/0.styles.d1b2acc8.css" as="style"><link rel="preload" href="/wiki/assets/js/app.fd78a570.js" as="script"><link rel="preload" href="/wiki/assets/js/2.de97d07c.js" as="script"><link rel="preload" href="/wiki/assets/js/4.f50a9bed.js" as="script"><link rel="prefetch" href="/wiki/assets/js/10.cffe816a.js"><link rel="prefetch" href="/wiki/assets/js/11.43cf2d5d.js"><link rel="prefetch" href="/wiki/assets/js/12.42d7bcac.js"><link rel="prefetch" href="/wiki/assets/js/13.0e7e5704.js"><link rel="prefetch" href="/wiki/assets/js/14.b4298d3a.js"><link rel="prefetch" href="/wiki/assets/js/15.34e7fde8.js"><link rel="prefetch" href="/wiki/assets/js/3.c1145f8a.js"><link rel="prefetch" href="/wiki/assets/js/5.0485e6fc.js"><link rel="prefetch" href="/wiki/assets/js/6.a19971b6.js"><link rel="prefetch" href="/wiki/assets/js/7.70076071.js"><link rel="prefetch" href="/wiki/assets/js/8.05f64b4c.js"><link rel="prefetch" href="/wiki/assets/js/9.c87ca447.js">
    <link rel="stylesheet" href="/wiki/assets/css/0.styles.d1b2acc8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki/" class="home-link router-link-active"><!----> <span class="site-name">Guxi11 的知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wiki/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE Menu" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/fe/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/javascript/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/network/" class="nav-link">
  网络
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/browser/" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><a href="/wiki/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/hbhde/wiki" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wiki/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE Menu" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/wiki/fe/html/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/css/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/javascript/" class="nav-link router-link-active">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/network/" class="nav-link">
  网络
</a></li><li class="dropdown-item"><!----> <a href="/wiki/fe/browser/" class="nav-link">
  浏览器
</a></li></ul></div></div><div class="nav-item"><a href="/wiki/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/hbhde/wiki" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/fe/javascript/" class="sidebar-link">首页</a></li><li><a href="/wiki/fe/javascript/data types.html" class="sidebar-link">数据类型</a></li><li><a href="/wiki/fe/javascript/inherit.html" class="active sidebar-link">JavaScript常用的八种继承方案</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_1、原型链继承" class="sidebar-link">1、原型链继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_2、借用构造函数继承" class="sidebar-link">2、借用构造函数继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_3、组合继承" class="sidebar-link">3、组合继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_4、原型式继承" class="sidebar-link">4、原型式继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_5、寄生式继承" class="sidebar-link">5、寄生式继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_6、寄生组合式继承" class="sidebar-link">6、寄生组合式继承</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_7、混入方式继承多个对象" class="sidebar-link">7、混入方式继承多个对象</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#_8、es6类继承extends" class="sidebar-link">8、ES6类继承extends</a></li><li class="sidebar-sub-header"><a href="/wiki/fe/javascript/inherit.html#参考资料" class="sidebar-link">参考资料</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript常用的八种继承方案"><a href="#javascript常用的八种继承方案" class="header-anchor">#</a> JavaScript常用的八种继承方案</h1> <h2 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h2> <p>首先我们约定一下接下来使用到的符号的含义：</p> <ol><li><code>===</code>: 上面的线是 <code>prototype</code> 线段（方向省略了，下同），下面的线是 <code>constructor</code> 线段</li> <li><code>/</code>: <code>__proto__</code> 线段</li> <li><code>|</code> : 实例属性的继承</li> <li><code>+ properties</code>: 增加属性</li></ol> <p><em>基本上，这些符号与下图中的有向线段一一对应：</em></p> <p><img src="/wiki/assets/img/inherit00.aa578516.png" alt="继承"></p> <h2 id="_1、原型链继承"><a href="#_1、原型链继承" class="header-anchor">#</a> 1、原型链继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>            superType <span class="token operator">===</span><span class="token operator">=</span> superType<span class="token punctuation">.</span>prototype
                 <span class="token operator">|</span>           <span class="token operator">/</span> 
subType <span class="token operator">===</span><span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> properties
  <span class="token operator">|</span>         <span class="token operator">/</span>
<span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>由图可知，subType 的原型是 superType 的实例，再加上了一些属性。所以缺点是：</p> <ul><li>多个 subType 实例对原型类型的操作会改变这个实例（subType 的原型）。</li></ul> <h2 id="_2、借用构造函数继承"><a href="#_2、借用构造函数继承" class="header-anchor">#</a> 2、借用构造函数继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>superType
<span class="token operator">|</span>				
<span class="token operator">|</span> subType
<span class="token operator">|</span>  <span class="token operator">|</span>    
<span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p> <p>缺点：</p> <ul><li>只能继承父类的<strong>实例</strong>属性和方法，不能继承原型属性/方法</li> <li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul> <h2 id="_3、组合继承"><a href="#_3、组合继承" class="header-anchor">#</a> 3、组合继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>superType     superType <span class="token operator">===</span><span class="token operator">=</span> superType<span class="token punctuation">.</span>prototype
<span class="token operator">|</span>                 <span class="token operator">|</span>           <span class="token operator">/</span> 
<span class="token operator">|</span> subType <span class="token operator">===</span><span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> properties
<span class="token operator">|</span>  <span class="token operator">|</span>         <span class="token operator">/</span>
<span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>组合上述两种方法就是组合继承。用原型链实现对<strong>原型</strong>属性和方法的继承，用借用构造函数技术来实现<strong>实例</strong>属性的继承。</p> <p>从图中可以看出，superType 的实例属性被 superType 的原型和实例继承，所以有这样的缺点：</p> <ul><li>在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</li></ul> <h2 id="_4、原型式继承"><a href="#_4、原型式继承" class="header-anchor">#</a> 4、原型式继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>      obj
     <span class="token operator">/</span>
clone
</code></pre></div><p>缺点：</p> <ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li> <li>无法传递参数</li></ul> <h2 id="_5、寄生式继承"><a href="#_5、寄生式继承" class="header-anchor">#</a> 5、寄生式继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>      obj
     <span class="token operator">/</span>
clone <span class="token operator">+</span> properties
</code></pre></div><p>缺点同原型式继承。</p> <h2 id="_6、寄生组合式继承"><a href="#_6、寄生组合式继承" class="header-anchor">#</a> 6、寄生组合式继承</h2> <div class="language-js extra-class"><pre class="language-js"><code>superType <span class="token operator">===</span><span class="token operator">=</span> superType<span class="token punctuation">.</span>prototype
<span class="token operator">|</span>                  <span class="token operator">/</span> 
<span class="token operator">|</span> subType <span class="token operator">===</span><span class="token operator">=</span> prototype <span class="token operator">+</span> properties
<span class="token operator">|</span>  <span class="token operator">|</span>         <span class="token operator">/</span>
<span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>步骤：</p> <ul><li>父类初始化实例属性和原型属性</li> <li>子类初始化，并借用构造函数传递增强子类实例属性（支持传参和避免篡改）</li> <li>将子类原型指向父类原型，并修复因重写原型而失去的默认的constructor 属性</li> <li>新增子类原型属性</li></ul> <p>结合借用构造函数传递参数和寄生模式实现继承。从图中可以看出，原型链继承的缺点已经被避免了。</p> <p><strong>这是最成熟的方法，也是现在库实现的方法</strong></p> <h2 id="_7、混入方式继承多个对象"><a href="#_7、混入方式继承多个对象" class="header-anchor">#</a> 7、混入方式继承多个对象</h2> <div class="language-js extra-class"><pre class="language-js"><code>SuperClass1 <span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span> <span class="token class-name">SuperClass1</span><span class="token punctuation">.</span>prototype
<span class="token operator">|</span> SuperClass2              <span class="token operator">/</span>
<span class="token operator">|</span>  <span class="token operator">|</span> MyClass <span class="token operator">==</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span>prototype <span class="token operator">+</span> SuperClass2<span class="token punctuation">.</span>properties <span class="token operator">+</span> properties
<span class="token operator">|</span>  <span class="token operator">|</span>  <span class="token operator">|</span>       <span class="token operator">/</span>
<span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>步骤：</p> <ul><li>父类初始化实例属性和原型属性</li> <li>子类初始化，并借用构造函数传递增强子类实例属性（支持传参和避免篡改）</li> <li>将子类原型指向一个父类原型，在子类原型通过Object.assign复制其他父类的属性，修复因重写原型而被修改的默认的constructor 属性</li> <li>新增子类原型属性</li></ul> <h2 id="_8、es6类继承extends"><a href="#_8、es6类继承extends" class="header-anchor">#</a> 8、ES6类继承extends</h2> <div class="language-js extra-class"><pre class="language-js"><code>superType <span class="token operator">===</span><span class="token operator">=</span> superType<span class="token punctuation">.</span>prototype
<span class="token operator">|</span>    <span class="token regex">/              /</span> 
<span class="token operator">|</span> subType <span class="token operator">===</span><span class="token operator">=</span> prototype <span class="token operator">+</span> properties
<span class="token operator">|</span>  <span class="token operator">|</span>         <span class="token operator">/</span>
<span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>注意这里 subType 的对象原型指向了 superType。<code>extends</code> 继承的核心代码如下，其实现和上述的寄生组合式的原型继承方式一样，不过多做了一件事，把 subType 的对象原型指向了 superType。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
    <span class="token comment">// 创建对象，创建父类原型的一个副本</span>
    <span class="token comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span>
    <span class="token comment">// 指定对象，将新创建的对象赋值给子类的原型</span>
    subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType <span class="token operator">&amp;&amp;</span> superType<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        constructor<span class="token operator">:</span> <span class="token punctuation">{</span>
            value<span class="token operator">:</span> subType<span class="token punctuation">,</span>
            enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
            writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            configurable<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// subType 的对象原型指向 superType</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>superType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span>setPrototypeOf 
            <span class="token operator">?</span> Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span> 
            <span class="token operator">:</span> subType<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> superType<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，为什么 subType <code>__proto__</code> 要指向 superType？</p> <ul><li><p>原型分为对象原型 <code>__proto__</code> 和函数原型 <code>prototype</code> 。</p></li> <li><p>函数也是一个对象，这里是为了继承 superType 上的方法。</p> <ul><li>设置subType.prototype，只有通过new生成的subType实例才会继承superType.prototype上的方法。</li> <li>设置subType.__proto__ = superType，则直接调用subType.xxx 时也会继承superType上的方法（superType.xxx），比如Array.isArray()。这也被称为类方法。</li></ul></li></ul> <p>这上面的都可以说是语法糖。</p> <p>下面来考察一下 ES6 继承和 ES5 的区别：</p> <p>可以看一下这段 MDN 上的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Polygon</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">height<span class="token punctuation">,</span> width</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Rectangle'</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi, I am a '</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">get</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_area <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Square</span> <span class="token keyword">extends</span> <span class="token class-name">Polygon</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">length</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token punctuation">;</span> <span class="token comment">// ReferenceError，super 需要先被调用！</span>
    
    <span class="token comment">// 这里，它调用父类的构造函数的, </span>
    <span class="token comment">// 作为Polygon 的 height, width</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 注意: 在派生的类中, 在你可以使用'this'之前, 必须先调用super()。</span>
    <span class="token comment">// 忽略这一点的话, 将导致引用错误。</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Square'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>super</code> 调用了父类的构造函数。实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。并不是说在使用super()之前子类没有this，而是ES6规定在super()调用之前，不能在子类构造器中使用this。这是为了靠近 Java 的语法，即确保先执行父类构造器才能访问this。</p> <p>由此可见，ES6的super(...args) 不等价于 Parent.apply(this, args)。所以 ES6 class 不是单纯语法糖。</p> <p>总结一下，ES5 与 ES6 的区别：</p> <ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）。</li> <li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。</li></ul> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="https://juejin.im/post/5bcb2e295188255c55472db0" target="_blank" rel="noopener noreferrer">JavaScript常用八种继承方案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super" target="_blank" rel="noopener noreferrer">MDN super<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>https://github.com/yygmind/blog/issues/7</li> <li>ES6的子类有没有自己的this？ - 贺师俊的回答 - 知乎 https://www.zhihu.com/question/378032472/answer/1089697467</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/fe/javascript/data types.html" class="prev">
        数据类型
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wiki/assets/js/app.fd78a570.js" defer></script><script src="/wiki/assets/js/2.de97d07c.js" defer></script><script src="/wiki/assets/js/4.f50a9bed.js" defer></script>
  </body>
</html>
